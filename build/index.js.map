{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": [
    "/**\n * Balance tags of html string\n * @param html - unbalanced or balanced html string\n * @returns balanced html string\n * @example\n * ```ts\n * const htmlStr = `<div>\n * <br></div>\n    <img src=\"/idb/files?id=vEQibqclfEKwjhM&amp;fk=Frq9gA68GK21saU\" data-id=\"vEQibqclfEKwjhM\" data-type=\"drawing\"\n        width=\"300\" data-fk=\"Frq9gA68GK21saU\" style=\"background-color: rgb(255, 255, 255);\">\n    <br>\n    </div>`;\n\n    // removes the extra closing div\n    const outputStr = tagBalancer(htmlStr); \n    \n * ```\n */\nexport function tagBalancer(html: string) {\n    if (!html) return \"\";\n\n    /** \n     * attempt to balance HTML tags in the html string\n     * by removing any unmatched opening or closing tags\n     * IMPORTANT: we *assume* HTML has *already* been \n     * sanitized and is safe/sane before balancing!\n     * \n     * adapted from CODESNIPPET: A8591DBA-D1D3-11DE-947C-BA5556D89593\n     */\n    var re = /<\\/?\\w+[^>]*(\\s|$|>)/g;\n\n    // convert everything to lower case; this makes\n    // our case insensitive comparisons easier\n    var tags = html.toLowerCase().match(re);\n    // console.debug(tags)\n    // if (!tags) return \"\";\n    if (!tags) return html;\n\n    // no HTML tags present? nothing to do; exit now\n    var tagcount = (tags || []).length;\n    if (tagcount == 0)\n        return html;\n\n    var tagname: string, tag: string;\n    var ignoredtags = /\\b{p|img|br|input|li|hr}\\b/;\n    var match;\n    var tagpaired: boolean[] = [];\n    var tagremove: boolean[] = [];\n    var needsRemoval = false;\n\n    // loop through matched tags in forward order\n    for (var ctag = 0; ctag < tagcount; ctag++) {\n\n        // tagname = tags[ctag].replace(/<\\/?(\\w+).*/, \"$1\");\n        tagname = tags[ctag].replace(/<\\/?(\\w+)[\\s\\S]*/, \"$1\");\n\n        // console.debug('HS>balanceTag:', tagname, tagpaired[ctag] || ignoredtags.has(tagname) ? (tagpaired[ctag] ? \"paired\" : \"ignored\") : '');\n\n        // skip any already paired tags\n        // and skip tags in our ignore list; assume they're self-closed\n        if (tagpaired[ctag] || ignoredtags.test(tagname))\n            continue;\n\n        tag = tags[ctag];\n        match = -1;\n\n        if (!/^<\\//.test(tag)) {\n            // this is an opening tag\n            // search forwards (next tags), look for closing tags\n            for (var ntag = ctag + 1; ntag < tagcount; ntag++) {\n                if (!tagpaired[ntag] && tags[ntag] == \"</\" + tagname + \">\") {\n                    match = ntag;\n                    break;\n                }\n            }\n        }\n\n        if (match == -1 /* || !all_tag_whitelist.test(tag?.match(/<([a-zA-Z][^\\s>]*)\\s*([^>]*)>/)?.[1] || '') */)\n            needsRemoval = tagremove[ctag] = true; // mark for removal\n        else\n            tagpaired[match] = true; // mark paired\n    }\n\n    if (!needsRemoval)\n        return html.trim();\n\n    // delete all orphaned tags from the string\n    var ctag = 0;\n    html = html.replace(re, function (match) {\n        var res = tagremove[ctag] ? \"\" : match;\n        ctag++;\n        return res;\n    });\n    return html.trim();\n}\n"
  ],
  "mappings": "AAkBO,SAAS,CAAW,CAAC,EAAc,CACtC,IAAK,EAAM,MAAO,GAUlB,IAAI,EAAK,wBAIL,EAAO,EAAK,YAAY,EAAE,MAAM,CAAE,EAGtC,IAAK,EAAM,OAAO,EAGlB,IAAI,GAAY,GAAQ,CAAC,GAAG,OAC5B,GAAI,GAAY,EACZ,OAAO,EAEX,IAAI,EAAiB,EACjB,EAAc,6BACd,EACA,EAAuB,CAAC,EACxB,EAAuB,CAAC,EACxB,EAAe,GAGnB,QAAS,EAAO,EAAG,EAAO,EAAU,IAAQ,CASxC,GANA,EAAU,EAAK,GAAM,QAAQ,mBAAoB,IAAI,EAMjD,EAAU,IAAS,EAAY,KAAK,CAAO,EAC3C,SAKJ,GAHA,EAAM,EAAK,GACX,EAAQ,IAEH,OAAO,KAAK,CAAG,GAGhB,QAAS,EAAO,EAAO,EAAG,EAAO,EAAU,IACvC,IAAK,EAAU,IAAS,EAAK,IAAS,KAAO,EAAU,IAAK,CACxD,EAAQ,EACR,OAKZ,GAAI,GAAS,GACT,EAAe,EAAU,GAAQ,OAEjC,GAAU,GAAS,GAG3B,IAAK,EACD,OAAO,EAAK,KAAK,EAGrB,IAAI,EAAO,EAMX,OALA,EAAO,EAAK,QAAQ,UAAa,CAAC,EAAO,CACrC,IAAI,EAAM,EAAU,GAAQ,GAAK,EAEjC,OADA,IACO,EACV,EACM,EAAK,KAAK",
  "debugId": "8B19E1AD4131A9B164756E2164756E21",
  "names": []
}